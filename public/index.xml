<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>FX思惑</title>
    <link>https://www.feixiang.name/</link>
    <description>Recent content on FX思惑</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Sun, 12 Nov 2017 09:22:36 +0800</lastBuildDate>
    
	<atom:link href="https://www.feixiang.name/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>玩一玩Termux</title>
      <link>https://www.feixiang.name/posts/termux/</link>
      <pubDate>Sun, 12 Nov 2017 09:22:36 +0800</pubDate>
      
      <guid>https://www.feixiang.name/posts/termux/</guid>
      <description>Termux是一款Android上的Linux环境终端模拟器，可以在上面安装各种linux 命令行软件 python、golang、nodejs&amp;hellip; 项目github主页
安装app后，首先安装 openssh pkg install openssh 搭建ssh服务。 https://termux.com/ssh.html, 安装完之后执行 sshd 即可启动一个ssh server, 默认端口 8022，就下来就可以用电脑ssh连接手机了。 Termux sshd 不支持密码登录，所以得把你的PC上的id_rsa.pub 写入到 Termux的 ~/.ssh/authorized_keys 中，如果没有的话用 ssh-keygen 生成一个。 复制到手机比较麻烦，我这里先通过QQ传到手机，在termux上执行 termux-setup-storage 可以让termux访问手机存储，找到QQ的目录 Tencent 下面的接收文件目录。 cat id_rsa.pub &amp;gt; ~/.ssh/authorized_keys 即可访问，例 ssh 192.168.1.3 -p 8022。
连上了ssh，就是发挥你想象力的时候了。
如果要随时随地远程访问可以配合使用 autossh + 反向连接 http://www.cnblogs.com/eshizhan/archive/2012/07/16/2592902.html
能访问后改成清华软件源可以软件包下载速度: https://mirror.tuna.tsinghua.edu.cn/help/termux/
习惯zsh的可以安装ohmyzsh https://github.com/Cabbagec/termux-ohmyzsh</description>
    </item>
    
    <item>
      <title>十一长假流水</title>
      <link>https://www.feixiang.name/posts/%E5%8D%81%E4%B8%80%E9%95%BF%E5%81%87/</link>
      <pubDate>Sun, 08 Oct 2017 11:30:02 +0800</pubDate>
      
      <guid>https://www.feixiang.name/posts/%E5%8D%81%E4%B8%80%E9%95%BF%E5%81%87/</guid>
      <description>十一在高速公路、泰兴、南通老家、杭州各呆了两天。
1号一整天都在高速公路上，再也不想经历这样的马拉松式的堵车。
2号小袁老师弟弟结婚，在泰兴住了2天。
3号到家吃晚饭，前面的那户人家还养着鸽子，村子前后10几年基本上没什么变化。村里小路上看到的都是老人在闲暇的走过，年轻人都往城里去生活了，放长假也没有回来的样子，我的家里也是常年没有人居住。
放假前买了几本书，原本打算十一就在家躺床上看看书度过。回家后呢跑来跑去，人来人往的，也没有完整的时间集中精力去看技术书。 手机上看了几篇关于tcp的文章，自己对tcp/ip不是很熟悉，只停留在web应用上，大概了解tcp/ip分层模型，tcp、udp的区别，tcp的一些算法，但是细节从来没有深挖过，也没想过要自己实现一把tcp/ip协议栈看看。不只是tcp/ip，其他计算机相关领域也一样很少关注和学习，有时候在想，十年、二十年之后自己有什么竞争力，至少现在来看感觉就要步入30岁淘汰的路了。
在微信上看了一本书 《跑步，成为最好的自己》 ，虽然是本鸡汤书，但是讲的挺让我触动。有感触是因为，之前自己也经历过一段时间的坚持跑步，能够感受到跑步带来的正面影响。
如果采取积极的行动，你就能让自己产生正面的想法，而跑步是一个改变的契机  书里面还有两个观点，解释了我之前跑步时的疑惑。
1. 坚持晨跑 // 如果你打算晚上跑步，可能会发生很多意想不到的事情打乱你的计划，但是早上一般不会。 2. 坚持在雨天和雪天跑步 // 现在的装备允许你在雨天跑步，享受坚持！  看完这本书，又有了强烈的想恢复跑步的冲动，现在跑步最难的倒不是早起，而是找不到合适的跑步的地方，真想住到大学或者公园旁边去。
5号回到杭州后，爬了下北高峰，吃了一直心心念念的素食餐厅。 晚上回家看了个注册域名的广告，受到诱惑点进去看了看，于是就注册了个域名 feixiang.name ，之前注册过feixiang.me，后来觉得续费太贵，难得又看到自己名字拼音没被注册而且续费不贵的域名，打算长期持有了。为了这个域名重新折腾了下博客，折腾了下 HTTPS，本来想直接丢到阿里云CDN和OSS上，但是域名要备案，而备案必须要买压根用不到的主机，也是醉了。
就这样，讲个恐怖的故事：十一长假结束了。</description>
    </item>
    
    <item>
      <title>简易的基于iptables和nginx访问日志屏蔽爬虫的方法</title>
      <link>https://www.feixiang.name/posts/ban-ip/</link>
      <pubDate>Wed, 20 Apr 2016 11:15:27 +0000</pubDate>
      
      <guid>https://www.feixiang.name/posts/ban-ip/</guid>
      <description>最近网站数据总是被人爬取，一天爬取几百万次,还会经常换ip。写了个简单粗暴的shell脚本，根据nginx访问日志，分析出最像爬虫的ip，然后用iptable来封掉这个ip。
/sbin/iptables -nvL INPUT | awk &#39;{if(NR&amp;gt;2)print $8}&#39; &amp;gt; /dev/shm/nginx_iptable_list # 列出当前封禁ip的名单,写到 /dev/shm/nginx_iptable_list 中 # /dev/shm是一个tmpfs基于内存的文件系统，有利于加快速度 # iptables -n 表示用数字形式显示ip地址和端口号，不然会用hostname来显示 # iptables -v 显示详细的调试信息 # iptables -L INPUT 列出INPUT，不指定则列出所有 这里我们封杀爬虫只需要INPUT就行 # awk NR是特殊变量,这边用来过滤掉数据前两行  tail -n 100000 /var/log/nginx/access.log | grep -i -v -E &#39;(192.168.*)|(127.0.0.1)&#39; | awk &#39;{print $1}&#39; | sort | uniq -c | sort -rn | awk &#39;{if($1&amp;gt;&#39;1000&#39;)print $2}&#39; | sort | uniq &amp;gt; /dev/shm/nginx_ip_to_ban_pre # 这里用了简单粗暴的方法分析出最近100000万次请求，同一个ip访问超过1000次的ip。 # grep -i 忽略大小写 -v 取反，表示选择不匹配的 -E 正则表达式 # &#39;(192.</description>
    </item>
    
    <item>
      <title>监控动态创建的script标签</title>
      <link>https://www.feixiang.name/posts/monitor-dynamic-inject-js/</link>
      <pubDate>Tue, 12 Apr 2016 17:36:55 +0000</pubDate>
      
      <guid>https://www.feixiang.name/posts/monitor-dynamic-inject-js/</guid>
      <description>动态创建script标签很常用，比如jsonp、amd 等等技术都会用到， 有时候我们会希望能够监控和拦截动态创建的script标签。 下面提供了一种代理document.createElement的方法来监控。
var _createElement = document.createElement var __define_src = function(script){ var src Object.defineProperty(script,&#39;src&#39;,{ get : function(){ return src }, set : function(s){ src = s script.setAttribute(&#39;src&#39;,s) } }) var _setAttribute = script.setAttribute script.setAttribute = function(){ var args = Array.prototype.slice.call(arguments) if(args[0] === &#39;src&#39;){ //do something here console.log(&#39;setAttribute&#39;,args[1]) } _setAttribute.apply(script,args) } } document.createElement = function(tagName){ var dom dom = _createElement.call(document,tagName) if(tagName.toLowerCase() === &#39;script&#39;){ __define_src(dom) } return dom }  上面的代码加载完后，就可以监控到 script.</description>
    </item>
    
    <item>
      <title>关于JS函数的bind方法</title>
      <link>https://www.feixiang.name/posts/about-js-bind/</link>
      <pubDate>Thu, 24 Mar 2016 17:09:05 +0000</pubDate>
      
      <guid>https://www.feixiang.name/posts/about-js-bind/</guid>
      <description>昨天被人问到js的bind的作用是什么？
这个倒还能回答出来，bind 之后返回一个新的函数，这个函数可以保持传递的this上下文。
接着又问了，那么bind两次不同的上下文会怎样？
这个一下子就蒙了，因为平时也没这么用过，于是开始查一下资料。
首先在浏览器中测试一下。
function test(){ console.log(this.a) } var bind1 = test.bind({a:1}) //第一次 bind var bind2 = bind1.bind({a:2}) // 第二次 bind bind1() bind2()  结果如下
1 1  可以看到第二次bind并没有能再改变this的值。
查一下MDN，Function.prototype.bind() , 并没有解释bind两次会怎样。 但是他提供了一个Polyfill，可以了解下bind的实现。
if (!Function.prototype.bind) { Function.prototype.bind = function(oThis) { if (typeof this !== &#39;function&#39;) { // closest thing possible to the ECMAScript 5 // internal IsCallable function throw new TypeError(&#39;Function.prototype.bind - what is trying to be bound is not callable&#39;); } var aArgs = Array.</description>
    </item>
    
  </channel>
</rss>