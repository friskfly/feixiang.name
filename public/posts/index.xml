<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on FX的所见所闻，所惑所思</title>
    <link>https://feixiang.name/posts/</link>
    <description>Recent content in Posts on FX的所见所闻，所惑所思</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Wed, 20 Apr 2016 11:15:27 +0000</lastBuildDate>
    
	<atom:link href="https://feixiang.name/posts/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>简易的基于iptables和nginx访问日志屏蔽爬虫的方法</title>
      <link>https://feixiang.name/posts/ban-ip/</link>
      <pubDate>Wed, 20 Apr 2016 11:15:27 +0000</pubDate>
      
      <guid>https://feixiang.name/posts/ban-ip/</guid>
      <description>最近网站数据总是被人爬取，一天爬取几百万次,还会经常换ip。写了个简单粗暴的shell脚本，根据nginx访问日志，分析出最像爬虫的ip，然后用iptable来封掉这个ip。
/sbin/iptables -nvL INPUT | awk &#39;{if(NR&amp;gt;2)print $8}&#39; &amp;gt; /dev/shm/nginx_iptable_list # 列出当前封禁ip的名单,写到 /dev/shm/nginx_iptable_list 中 # /dev/shm是一个tmpfs基于内存的文件系统，有利于加快速度 # iptables -n 表示用数字形式显示ip地址和端口号，不然会用hostname来显示 # iptables -v 显示详细的调试信息 # iptables -L INPUT 列出INPUT，不指定则列出所有 这里我们封杀爬虫只需要INPUT就行 # awk NR是特殊变量,这边用来过滤掉数据前两行  tail -n 100000 /var/log/nginx/access.log | grep -i -v -E &#39;(192.168.*)|(127.0.0.1)&#39; | awk &#39;{print $1}&#39; | sort | uniq -c | sort -rn | awk &#39;{if($1&amp;gt;&#39;1000&#39;)print $2}&#39; | sort | uniq &amp;gt; /dev/shm/nginx_ip_to_ban_pre # 这里用了简单粗暴的方法分析出最近100000万次请求，同一个ip访问超过1000次的ip。 # grep -i 忽略大小写 -v 取反，表示选择不匹配的 -E 正则表达式 # &#39;(192.</description>
    </item>
    
    <item>
      <title>监控动态创建的script标签</title>
      <link>https://feixiang.name/posts/monitor-dynamic-inject-js/</link>
      <pubDate>Tue, 12 Apr 2016 17:36:55 +0000</pubDate>
      
      <guid>https://feixiang.name/posts/monitor-dynamic-inject-js/</guid>
      <description>动态创建script标签很常用，比如jsonp、amd 等等技术都会用到， 有时候我们会希望能够监控和拦截动态创建的script标签。 下面提供了一种代理document.createElement的方法来监控。
var _createElement = document.createElement var __define_src = function(script){ var src Object.defineProperty(script,&#39;src&#39;,{ get : function(){ return src }, set : function(s){ src = s script.setAttribute(&#39;src&#39;,s) } }) var _setAttribute = script.setAttribute script.setAttribute = function(){ var args = Array.prototype.slice.call(arguments) if(args[0] === &#39;src&#39;){ //do something here console.log(&#39;setAttribute&#39;,args[1]) } _setAttribute.apply(script,args) } } document.createElement = function(tagName){ var dom dom = _createElement.call(document,tagName) if(tagName.toLowerCase() === &#39;script&#39;){ __define_src(dom) } return dom }  上面的代码加载完后，就可以监控到 script.</description>
    </item>
    
    <item>
      <title>关于JS函数的bind方法</title>
      <link>https://feixiang.name/posts/about-js-bind/</link>
      <pubDate>Thu, 24 Mar 2016 17:09:05 +0000</pubDate>
      
      <guid>https://feixiang.name/posts/about-js-bind/</guid>
      <description>昨天被人问到js的bind的作用是什么？
这个倒还能回答出来，bind 之后返回一个新的函数，这个函数可以保持传递的this上下文。
接着又问了，那么bind两次不同的上下文会怎样？
这个一下子就蒙了，因为平时也没这么用过，于是开始查一下资料。
首先在浏览器中测试一下。
function test(){ console.log(this.a) } var bind1 = test.bind({a:1}) //第一次 bind var bind2 = bind1.bind({a:2}) // 第二次 bind bind1() bind2()  结果如下
1 1  可以看到第二次bind并没有能再改变this的值。
查一下MDN，Function.prototype.bind() , 并没有解释bind两次会怎样。 但是他提供了一个Polyfill，可以了解下bind的实现。
if (!Function.prototype.bind) { Function.prototype.bind = function(oThis) { if (typeof this !== &#39;function&#39;) { // closest thing possible to the ECMAScript 5 // internal IsCallable function throw new TypeError(&#39;Function.prototype.bind - what is trying to be bound is not callable&#39;); } var aArgs = Array.</description>
    </item>
    
  </channel>
</rss>